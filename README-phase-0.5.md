# Phase 0.5: Ë¶≥Ê∏¨Âü∫Áõ§ÊßãÁØâ ÂÆüË£ÖÊâãÈ†Ü

> „Ç∑„Çπ„ÉÜ„É†ÂèØË¶≥Ê∏¨ÊÄß„ÅÆÁ¢∫‰øù„Å´„Çà„Çä„ÄÅ‰ª•Èôç„ÅÆÂÖ®Phase„Åß„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„ÉªÂìÅË≥™‰øùË®º„ÇíÂÆüÁèæ

## üéØ PhaseÊ¶ÇË¶Å

**ÊúüÈñì**: 1-2Êó•Èñì  
**„Éñ„É©„É≥„ÉÅ**: `feature/monitoring`  
**ÂâçÊèêÊù°‰ª∂**: Phase 0Ôºà„ÉÜ„Çπ„ÉàÂü∫Áõ§ÔºâÂÆå‰∫Ü  
**ÁõÆÊ®ô**: „Ç®„É©„ÉºÁéá1%Êú™Ê∫Ä„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõÆÊ®ôÈÅîÊàê„ÄÅÂÆåÂÖ®ÂèØË¶≥Ê∏¨ÊÄß

## üìã ÂÆüË£Ö„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà

### Day 1: „Ç®„É©„Éº„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞„Éª„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
- [ ] SentryÁµ±Âêà„ÉªË®≠ÂÆö
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É°„Éà„É™„ÇØ„ÇπÂèéÈõÜÂü∫Áõ§
- [ ] Web VitalsÁõ£Ë¶ñË®≠ÂÆö
- [ ] „Ç´„Çπ„Çø„É†„É°„Éà„É™„ÇØ„ÇπÂÆüË£Ö
- [ ] „Ç®„É©„Éº„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ë®≠ÂÆö

### Day 2: „É¶„Éº„Ç∂„ÉºË°åÂãïÂàÜÊûê„Éª„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ
- [ ] „É¶„Éº„Ç∂„ÉºË°åÂãïËøΩË∑°Âü∫Áõ§
- [ ] „Ç¢„É©„Éº„Éà„Ç∑„Çπ„ÉÜ„É†ÊßãÁØâ
- [ ] „É™„Ç¢„É´„Çø„Ç§„É†„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê
- [ ] Áµ±Ë®à„É¨„Éù„Éº„ÉàÊ©üËÉΩ
- [ ] PhaseÂÆå‰∫ÜÁ¢∫Ë™ç

## üöÄ ÂÆüË£ÖÊâãÈ†Ü

### Step 1: „Éñ„É©„É≥„ÉÅÊ∫ñÂÇô

```bash
# Phase 0ÂÆå‰∫Ü„Éñ„É©„É≥„ÉÅ„Åã„ÇâÈñãÂßã
git checkout feature/test-infrastructure
git pull origin feature/test-infrastructure

# Phase 0.5„Éñ„É©„É≥„ÉÅ‰ΩúÊàê
git checkout -b feature/monitoring

# ÈñãÂßã„Çø„Ç∞
git tag phase-0.5-start
```

### Step 2: ÂøÖË¶Å„Éë„ÉÉ„Ç±„Éº„Ç∏„Ç§„É≥„Çπ„Éà„Éº„É´

```bash
# SentryÁµ±Âêà
npm install @sentry/nextjs @sentry/replay

# „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
npm install web-vitals

# „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Éª„ÉÅ„É£„Éº„Éà
npm install chart.js react-chartjs-2
npm install recharts

# „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
npm install uuid
npm install -D @types/uuid
```

### Step 3: SentryÁµ±ÂêàË®≠ÂÆö

**sentry.client.config.ts**
```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  
  integrations: [
    new Sentry.BrowserTracing({
      tracePropagationTargets: [
        "localhost",
        /^https:\/\/.*\.vercel\.app/,
        /^https:\/\/your-domain\.com/
      ],
      routingInstrumentation: Sentry.nextRouterInstrumentation,
    }),
    new Sentry.Replay({
      maskAllText: false,
      blockAllMedia: false,
    }),
  ],
  
  tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  
  beforeSend(event, hint) {
    // ÈñãÁô∫Áí∞Â¢É„Éé„Ç§„Ç∫Èô§Âéª
    if (process.env.NODE_ENV === 'development') {
      if (hint.originalException?.message?.includes('ResizeObserver')) {
        return null;
      }
      if (hint.originalException?.message?.includes('Non-Error promise rejection')) {
        return null;
      }
    }
    
    // Ê©üÂØÜÊÉÖÂ†±„ÅÆ„Éû„Çπ„Ç≠„É≥„Ç∞
    if (event.request?.cookies) {
      delete event.request.cookies;
    }
    
    if (event.extra?.password || event.extra?.token) {
      delete event.extra.password;
      delete event.extra.token;
    }
    
    return event;
  },
});
```

**sentry.server.config.ts**
```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Mongo(),
  ],
  
  tracesSampleRate: process.env.NODE_ENV === "production" ? 0.05 : 1.0,
  
  beforeSend(event) {
    // „Çµ„Éº„Éê„Éº„Çµ„Ç§„ÉâÊ©üÂØÜÊÉÖÂ†±‰øùË≠∑
    if (event.request?.data) {
      const data = event.request.data;
      if (typeof data === 'object' && data !== null) {
        ['password', 'token', 'secret', 'key'].forEach(key => {
          if (key in data) {
            data[key] = '[Filtered]';
          }
        });
      }
    }
    
    return event;
  },
});
```

### Step 4: „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É°„Éà„É™„ÇØ„ÇπÂèéÈõÜÂü∫Áõ§

**src/lib/monitoring/performance-monitor.ts**
```typescript
import { performance } from 'perf_hooks';
import * as Sentry from '@sentry/nextjs';

export interface PerformanceMetrics {
  operation: string;
  duration: number;
  timestamp: number;
  success: boolean;
  metadata?: Record<string, any>;
}

export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Map<string, PerformanceMetrics[]> = new Map();
  private readonly MAX_METRICS_PER_OPERATION = 1000;

  public static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  async measureOperation<T>(
    operation: string,
    fn: () => Promise<T>,
    metadata?: Record<string, any>
  ): Promise<T> {
    const startTime = performance.now();
    const timestamp = Date.now();
    
    try {
      const result = await fn();
      const duration = performance.now() - startTime;
      
      this.recordMetric({
        operation,
        duration,
        timestamp,
        success: true,
        metadata,
      });
      
      this.checkPerformanceThresholds(operation, duration);
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      
      this.recordMetric({
        operation,
        duration,
        timestamp,
        success: false,
        metadata: { ...metadata, error: error.message },
      });
      
      Sentry.captureException(error, {
        tags: { operation },
        extra: { duration, metadata },
      });
      
      throw error;
    }
  }

  private recordMetric(metric: PerformanceMetrics) {
    if (!this.metrics.has(metric.operation)) {
      this.metrics.set(metric.operation, []);
    }

    const operationMetrics = this.metrics.get(metric.operation)!;
    operationMetrics.push(metric);

    // Âè§„ÅÑ„É°„Éà„É™„ÇØ„Çπ„ÇíÂâäÈô§„Åó„Å¶„É°„É¢„É™‰ΩøÁî®Èáè„ÇíÂà∂Èôê
    if (operationMetrics.length > this.MAX_METRICS_PER_OPERATION) {
      operationMetrics.shift();
    }

    // Sentry„Å´„Éñ„É¨„ÉÉ„Éâ„ÇØ„É©„É†ËøΩÂä†
    Sentry.addBreadcrumb({
      category: 'performance',
      message: `${metric.operation} ${metric.success ? 'completed' : 'failed'}`,
      level: metric.success ? 'info' : 'error',
      data: {
        duration: metric.duration,
        operation: metric.operation,
      },
    });
  }

  private checkPerformanceThresholds(operation: string, duration: number) {
    const thresholds: Record<string, number> = {
      'api.posts.list': 500,
      'api.posts.create': 300,
      'api.posts.update': 300,
      'api.posts.delete': 200,
      'auth.login': 500,
      'auth.register': 1000,
      'email.send': 2000,
      'db.query': 100,
      'db.insert': 200,
      'db.update': 200,
      'db.delete': 100,
    };

    const threshold = thresholds[operation];
    if (threshold && duration > threshold) {
      console.warn(`‚ö†Ô∏è Performance: ${operation} took ${duration.toFixed(2)}ms (threshold: ${threshold}ms)`);
      
      Sentry.captureMessage(
        `Performance threshold exceeded: ${operation}`,
        'warning'
      );
      
      // „Ç´„Çπ„Çø„É†„É°„Éà„É™„ÇØ„ÇπÈÄÅ‰ø°
      this.sendCustomMetric('performance_warning', 1, {
        operation,
        duration,
        threshold,
      });
    }
  }

  public getOperationStats(operation: string) {
    const metrics = this.metrics.get(operation);
    if (!metrics || metrics.length === 0) return null;

    const durations = metrics.map(m => m.duration);
    const successCount = metrics.filter(m => m.success).length;
    const sorted = [...durations].sort((a, b) => a - b);

    return {
      count: metrics.length,
      successRate: (successCount / metrics.length) * 100,
      avgDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
      medianDuration: sorted[Math.floor(sorted.length / 2)],
      p95Duration: sorted[Math.floor(sorted.length * 0.95)],
      p99Duration: sorted[Math.floor(sorted.length * 0.99)],
      minDuration: sorted[0],
      maxDuration: sorted[sorted.length - 1],
    };
  }

  public getAllStats() {
    const stats: Record<string, any> = {};
    for (const operation of this.metrics.keys()) {
      stats[operation] = this.getOperationStats(operation);
    }
    return stats;
  }

  private sendCustomMetric(name: string, value: number, tags?: Record<string, any>) {
    // „Ç´„Çπ„Çø„É†„É°„Éà„É™„ÇØ„ÇπÈÄÅ‰ø°ÔºàÂÆüË£Ö„ÅØÁõ£Ë¶ñ„Çµ„Éº„Éì„Çπ„Å´Âøú„Åò„Å¶Ë™øÊï¥Ôºâ
    console.log(`üìä Metric: ${name}=${value}`, tags);
    
    // SentryÁî®„Ç´„Çπ„Çø„É†„É°„Éà„É™„ÇØ„Çπ
    Sentry.metrics.increment(name, value, { tags });
  }
}

export const perfMonitor = PerformanceMonitor.getInstance();
```

### Step 5: Web VitalsÁõ£Ë¶ñ

**src/lib/monitoring/web-vitals.ts**
```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB, Metric } from 'web-vitals';
import * as Sentry from '@sentry/nextjs';

export function reportWebVitals() {
  // Cumulative Layout Shift
  getCLS(onPerfEntry);
  
  // First Input Delay
  getFID(onPerfEntry);
  
  // First Contentful Paint
  getFCP(onPerfEntry);
  
  // Largest Contentful Paint
  getLCP(onPerfEntry);
  
  // Time to First Byte
  getTTFB(onPerfEntry);
}

function onPerfEntry(metric: Metric) {
  console.log(`üìà ${metric.name}: ${metric.value}`);
  
  // Sentry„Å´ÈÄÅ‰ø°
  Sentry.addBreadcrumb({
    category: 'web-vitals',
    message: `${metric.name}: ${metric.value}`,
    level: 'info',
    data: {
      value: metric.value,
      rating: metric.rating,
      delta: metric.delta,
    },
  });
  
  // ÈñæÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
  const thresholds = {
    CLS: { good: 0.1, poor: 0.25 },
    FID: { good: 100, poor: 300 },
    FCP: { good: 1800, poor: 3000 },
    LCP: { good: 2500, poor: 4000 },
    TTFB: { good: 800, poor: 1800 },
  };
  
  const threshold = thresholds[metric.name as keyof typeof thresholds];
  if (threshold) {
    let level: 'info' | 'warning' | 'error' = 'info';
    
    if (metric.value > threshold.poor) {
      level = 'error';
    } else if (metric.value > threshold.good) {
      level = 'warning';
    }
    
    if (level !== 'info') {
      Sentry.captureMessage(
        `Web Vitals threshold exceeded: ${metric.name}`,
        level
      );
    }
  }
  
  // „Ç´„Çπ„Çø„É†ÂàÜÊûê„Çµ„Éº„Éì„Çπ„Å´ÈÄÅ‰ø°
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', metric.name, {
      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
      event_label: metric.id,
      non_interaction: true,
    });
  }
}

// Next.js App RouterÁî®
export function WebVitalsReporter() {
  if (typeof window !== 'undefined') {
    reportWebVitals();
  }
  return null;
}
```

### Step 6: „É¶„Éº„Ç∂„ÉºË°åÂãïÂàÜÊûêÂü∫Áõ§

**src/lib/monitoring/user-analytics.ts**
```typescript
import { v4 as uuidv4 } from 'uuid';
import * as Sentry from '@sentry/nextjs';

export interface UserEvent {
  eventId: string;
  eventName: string;
  userId?: string;
  sessionId: string;
  timestamp: number;
  properties: Record<string, any>;
  context: {
    userAgent: string;
    url: string;
    referrer: string;
  };
}

export class UserAnalytics {
  private static instance: UserAnalytics;
  private sessionId: string;
  private events: UserEvent[] = [];
  private readonly MAX_EVENTS = 500;

  constructor() {
    this.sessionId = this.generateSessionId();
  }

  public static getInstance(): UserAnalytics {
    if (!UserAnalytics.instance) {
      UserAnalytics.instance = new UserAnalytics();
    }
    return UserAnalytics.instance;
  }

  private generateSessionId(): string {
    const stored = typeof window !== 'undefined' 
      ? sessionStorage.getItem('analytics_session_id') 
      : null;
    
    if (stored) {
      return stored;
    }
    
    const sessionId = uuidv4();
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('analytics_session_id', sessionId);
    }
    
    return sessionId;
  }

  public track(eventName: string, properties: Record<string, any> = {}, userId?: string) {
    if (typeof window === 'undefined') return;

    const event: UserEvent = {
      eventId: uuidv4(),
      eventName,
      userId,
      sessionId: this.sessionId,
      timestamp: Date.now(),
      properties,
      context: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        referrer: document.referrer,
      },
    };

    this.events.push(event);

    // „Ç§„Éô„É≥„ÉàÊï∞Âà∂Èôê
    if (this.events.length > this.MAX_EVENTS) {
      this.events.shift();
    }

    // ÈñãÁô∫Áí∞Â¢É„Åß„ÅÆ„É≠„Ç∞Âá∫Âäõ
    if (process.env.NODE_ENV === 'development') {
      console.log(`üéØ Analytics: ${eventName}`, properties);
    }

    // Sentry„Éñ„É¨„ÉÉ„Éâ„ÇØ„É©„É†
    Sentry.addBreadcrumb({
      category: 'user-action',
      message: eventName,
      level: 'info',
      data: properties,
    });

    // Â§ñÈÉ®„Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„ÇπÈÄÅ‰ø°
    this.sendToExternalService(event);
  }

  private sendToExternalService(event: UserEvent) {
    // Google Analytics 4
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', event.eventName, {
        event_category: 'User Action',
        event_label: event.eventName,
        custom_map: event.properties,
        session_id: event.sessionId,
        user_id: event.userId,
      });
    }

    // „Ç´„Çπ„Çø„É†ÂàÜÊûê„Çµ„Éº„Éì„ÇπÔºàÂÆüË£Ö‰æãÔºâ
    if (process.env.NODE_ENV === 'production') {
      fetch('/api/analytics/events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(event),
      }).catch(error => {
        console.error('AnalyticsÈÄÅ‰ø°„Ç®„É©„Éº:', error);
      });
    }
  }

  // Ë™çË®ºÈñ¢ÈÄ£„Ç§„Éô„É≥„Éà
  public trackAuthEvent(event: 'login_start' | 'login_success' | 'login_failed' | 'register_start' | 'register_success' | 'register_failed' | 'logout', metadata?: any) {
    this.track(`auth.${event}`, metadata);
  }

  // „Éö„Éº„Ç∏„Éì„É•„Éº„Ç§„Éô„É≥„Éà
  public trackPageView(path: string, title?: string) {
    this.track('page_view', {
      path,
      title: title || document.title,
    });
  }

  // ÊäïÁ®øÈñ¢ÈÄ£„Ç§„Éô„É≥„Éà
  public trackPostEvent(event: 'create' | 'edit' | 'delete' | 'like' | 'view', postId?: string, metadata?: any) {
    this.track(`post.${event}`, {
      postId,
      ...metadata,
    });
  }

  // „Ç®„É©„Éº„Ç§„Éô„É≥„Éà
  public trackError(error: Error, context?: any) {
    this.track('error_occurred', {
      errorMessage: error.message,
      errorStack: error.stack,
      context,
    });
  }

  // Áµ±Ë®àÂèñÂæó
  public getSessionStats() {
    const sessionEvents = this.events.filter(e => e.sessionId === this.sessionId);
    
    return {
      sessionId: this.sessionId,
      eventCount: sessionEvents.length,
      firstEvent: sessionEvents[0]?.timestamp,
      lastEvent: sessionEvents[sessionEvents.length - 1]?.timestamp,
      sessionDuration: sessionEvents.length > 1 
        ? sessionEvents[sessionEvents.length - 1].timestamp - sessionEvents[0].timestamp
        : 0,
      topEvents: this.getTopEvents(sessionEvents),
    };
  }

  private getTopEvents(events: UserEvent[]) {
    const eventCounts: Record<string, number> = {};
    events.forEach(event => {
      eventCounts[event.eventName] = (eventCounts[event.eventName] || 0) + 1;
    });

    return Object.entries(eventCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));
  }
}

export const userAnalytics = UserAnalytics.getInstance();
```

### Step 7: „Ç¢„É©„Éº„Éà„Ç∑„Çπ„ÉÜ„É†

**src/lib/monitoring/alert-manager.ts**
```typescript
import * as Sentry from '@sentry/nextjs';

export interface AlertRule {
  name: string;
  condition: (metrics: any) => boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  cooldown: number; // Áßí
  actions: AlertAction[];
}

export interface AlertAction {
  type: 'email' | 'slack' | 'sentry' | 'console';
  config: Record<string, any>;
}

export class AlertManager {
  private static instance: AlertManager;
  private lastAlerted: Map<string, number> = new Map();
  private rules: AlertRule[] = [];

  constructor() {
    this.initializeDefaultRules();
  }

  public static getInstance(): AlertManager {
    if (!AlertManager.instance) {
      AlertManager.instance = new AlertManager();
    }
    return AlertManager.instance;
  }

  private initializeDefaultRules() {
    this.rules = [
      {
        name: 'high_error_rate',
        condition: (m) => m.errorRate > 5,
        severity: 'critical',
        message: '„Ç®„É©„ÉºÁéá„Åå5%„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô',
        cooldown: 300,
        actions: [
          { type: 'sentry', config: {} },
          { type: 'slack', config: { channel: '#alerts' } },
        ],
      },
      {
        name: 'slow_response_time',
        condition: (m) => m.avgResponseTime > 1000,
        severity: 'high',
        message: 'Âπ≥ÂùáÂøúÁ≠îÊôÇÈñì„Åå1Áßí„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô',
        cooldown: 600,
        actions: [
          { type: 'sentry', config: {} },
          { type: 'console', config: {} },
        ],
      },
      {
        name: 'memory_usage_high',
        condition: (m) => m.memoryUsage > 80,
        severity: 'medium',
        message: '„É°„É¢„É™‰ΩøÁî®Áéá„Åå80%„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô',
        cooldown: 300,
        actions: [
          { type: 'console', config: {} },
        ],
      },
      {
        name: 'database_connection_issues',
        condition: (m) => m.dbConnectionErrors > 3,
        severity: 'high',
        message: '„Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„Ç®„É©„Éº„ÅåÂ§öÁô∫„Åó„Å¶„ÅÑ„Åæ„Åô',
        cooldown: 300,
        actions: [
          { type: 'sentry', config: {} },
          { type: 'email', config: { to: 'admin@example.com' } },
        ],
      },
    ];
  }

  public checkAlerts(metrics: any) {
    this.rules.forEach(rule => {
      if (rule.condition(metrics)) {
        this.triggerAlert(rule, metrics);
      }
    });
  }

  private triggerAlert(rule: AlertRule, metrics: any) {
    const now = Date.now();
    const lastAlerted = this.lastAlerted.get(rule.name) || 0;

    // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥ÊúüÈñì‰∏≠„ÅØ„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°„Çí„Çπ„Ç≠„ÉÉ„Éó
    if (now - lastAlerted < rule.cooldown * 1000) {
      return;
    }

    console.log(`üö® Alert: ${rule.name} - ${rule.message}`);

    // „Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË°å
    rule.actions.forEach(action => {
      this.executeAction(action, rule, metrics);
    });

    this.lastAlerted.set(rule.name, now);
  }

  private executeAction(action: AlertAction, rule: AlertRule, metrics: any) {
    switch (action.type) {
      case 'sentry':
        Sentry.captureMessage(rule.message, this.getSentryLevel(rule.severity));
        break;

      case 'console':
        console.error(`üö® ${rule.severity.toUpperCase()}: ${rule.message}`, metrics);
        break;

      case 'slack':
        this.sendSlackAlert(rule, metrics, action.config);
        break;

      case 'email':
        this.sendEmailAlert(rule, metrics, action.config);
        break;
    }
  }

  private getSentryLevel(severity: string): 'info' | 'warning' | 'error' | 'fatal' {
    switch (severity) {
      case 'low': return 'info';
      case 'medium': return 'warning';
      case 'high': return 'error';
      case 'critical': return 'fatal';
      default: return 'warning';
    }
  }

  private async sendSlackAlert(rule: AlertRule, metrics: any, config: any) {
    if (!process.env.SLACK_WEBHOOK_URL) return;

    const payload = {
      text: `üö® ${rule.severity.toUpperCase()}: ${rule.message}`,
      attachments: [{
        color: this.getAlertColor(rule.severity),
        fields: Object.entries(metrics).map(([key, value]) => ({
          title: key,
          value: String(value),
          short: true,
        })),
        timestamp: Math.floor(Date.now() / 1000),
      }],
    };

    try {
      await fetch(process.env.SLACK_WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    } catch (error) {
      console.error('SlackÈÄöÁü•ÈÄÅ‰ø°„Ç®„É©„Éº:', error);
    }
  }

  private async sendEmailAlert(rule: AlertRule, metrics: any, config: any) {
    try {
      await fetch('/api/monitoring/send-alert-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          to: config.to,
          subject: `Alert: ${rule.message}`,
          rule,
          metrics,
        }),
      });
    } catch (error) {
      console.error('„É°„Éº„É´„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°„Ç®„É©„Éº:', error);
    }
  }

  private getAlertColor(severity: string): string {
    switch (severity) {
      case 'low': return '#36a64f';      // green
      case 'medium': return '#ff9500';   // orange  
      case 'high': return '#e01e5a';     // red
      case 'critical': return '#8b0000'; // dark red
      default: return '#808080';         // gray
    }
  }

  public addRule(rule: AlertRule) {
    this.rules.push(rule);
  }

  public removeRule(name: string) {
    this.rules = this.rules.filter(rule => rule.name !== name);
  }

  public getRules(): AlertRule[] {
    return [...this.rules];
  }
}

export const alertManager = AlertManager.getInstance();
```

### Step 8: „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê

**src/app/monitoring/dashboard/page.tsx**
```typescript
'use client';

import { useEffect, useState } from 'react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Grid,
  Typography,
  Alert,
  Box,
} from '@mui/material';
import { Line, Bar, Doughnut } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend
);

interface DashboardMetrics {
  errorRate: number;
  avgResponseTime: number;
  activeUsers: number;
  memoryUsage: number;
  cpuUsage: number;
  responseTimeHistory: number[];
  errorTypeDistribution: Record<string, number>;
  topPages: Array<{ path: string; views: number }>;
  timeline: string[];
}

export default function MonitoringDashboard() {
  const [metrics, setMetrics] = useState<DashboardMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchMetrics = async () => {
      try {
        const response = await fetch('/api/monitoring/metrics');
        if (!response.ok) {
          throw new Error('„É°„Éà„É™„ÇØ„ÇπÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
        }
        const data = await response.json();
        setMetrics(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchMetrics();
    const interval = setInterval(fetchMetrics, 30000); // 30Áßí„Åî„Å®

    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return <Typography>Ë™≠„ÅøËæº„Åø‰∏≠...</Typography>;
  }

  if (error) {
    return <Alert severity="error">„Ç®„É©„Éº: {error}</Alert>;
  }

  if (!metrics) {
    return <Alert severity="info">„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</Alert>;
  }

  const getStatusColor = (value: number, thresholds: { warning: number; error: number }) => {
    if (value >= thresholds.error) return 'error';
    if (value >= thresholds.warning) return 'warning';
    return 'success';
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        „Ç∑„Çπ„ÉÜ„É†Áõ£Ë¶ñ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ
      </Typography>

      <Grid container spacing={3}>
        {/* „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã */}
        <Grid item xs={12} md={3}>
          <Card>
            <CardHeader title="„Ç®„É©„ÉºÁéá" />
            <CardContent>
              <Typography 
                variant="h3" 
                color={getStatusColor(metrics.errorRate, { warning: 1, error: 5 })}
              >
                {metrics.errorRate.toFixed(2)}%
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} md={3}>
          <Card>
            <CardHeader title="Âπ≥ÂùáÂøúÁ≠îÊôÇÈñì" />
            <CardContent>
              <Typography 
                variant="h3" 
                color={getStatusColor(metrics.avgResponseTime, { warning: 500, error: 1000 })}
              >
                {metrics.avgResponseTime.toFixed(0)}ms
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} md={3}>
          <Card>
            <CardHeader title="„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„É¶„Éº„Ç∂„Éº" />
            <CardContent>
              <Typography variant="h3" color="primary">
                {metrics.activeUsers}
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} md={3}>
          <Card>
            <CardHeader title="„É°„É¢„É™‰ΩøÁî®Áéá" />
            <CardContent>
              <Typography 
                variant="h3" 
                color={getStatusColor(metrics.memoryUsage, { warning: 70, error: 85 })}
              >
                {metrics.memoryUsage.toFixed(1)}%
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        {/* „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éà„É¨„É≥„Éâ */}
        <Grid item xs={12} md={8}>
          <Card>
            <CardHeader title="ÂøúÁ≠îÊôÇÈñì„Éà„É¨„É≥„Éâ" />
            <CardContent>
              <Line
                data={{
                  labels: metrics.timeline,
                  datasets: [{
                    label: 'ÂøúÁ≠îÊôÇÈñì (ms)',
                    data: metrics.responseTimeHistory,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1,
                  }],
                }}
                options={{
                  responsive: true,
                  scales: {
                    y: {
                      beginAtZero: true,
                      title: {
                        display: true,
                        text: 'ÂøúÁ≠îÊôÇÈñì (ms)',
                      },
                    },
                  },
                }}
              />
            </CardContent>
          </Card>
        </Grid>

        {/* „Ç®„É©„ÉºÂàÜÂ∏É */}
        <Grid item xs={12} md={4}>
          <Card>
            <CardHeader title="„Ç®„É©„Éº„Çø„Ç§„ÉóÂàÜÂ∏É" />
            <CardContent>
              <Doughnut
                data={{
                  labels: Object.keys(metrics.errorTypeDistribution),
                  datasets: [{
                    data: Object.values(metrics.errorTypeDistribution),
                    backgroundColor: [
                      '#FF6384',
                      '#36A2EB',
                      '#FFCE56',
                      '#4BC0C0',
                      '#9966FF',
                    ],
                  }],
                }}
                options={{
                  responsive: true,
                  maintainAspectRatio: false,
                }}
              />
            </CardContent>
          </Card>
        </Grid>

        {/* „Éà„ÉÉ„Éó„Éö„Éº„Ç∏ */}
        <Grid item xs={12}>
          <Card>
            <CardHeader title="‰∫∫Ê∞ó„Éö„Éº„Ç∏" />
            <CardContent>
              <Bar
                data={{
                  labels: metrics.topPages.map(page => page.path),
                  datasets: [{
                    label: '„Éö„Éº„Ç∏„Éì„É•„Éº',
                    data: metrics.topPages.map(page => page.views),
                    backgroundColor: 'rgba(54, 162, 235, 0.8)',
                  }],
                }}
                options={{
                  responsive: true,
                  scales: {
                    y: {
                      beginAtZero: true,
                      title: {
                        display: true,
                        text: '„Éì„É•„ÉºÊï∞',
                      },
                    },
                  },
                }}
              />
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
}
```

### Step 9: API „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà‰ΩúÊàê

**src/app/api/monitoring/metrics/route.ts**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { perfMonitor } from '@/lib/monitoring/performance-monitor';

export async function GET(request: NextRequest) {
  try {
    // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁµ±Ë®àÂèñÂæó
    const performanceStats = perfMonitor.getAllStats();
    
    // „Ç∑„Çπ„ÉÜ„É†„É°„Éà„É™„ÇØ„ÇπÔºàÂÆüË£Ö‰æãÔºâ
    const systemMetrics = {
      errorRate: 0.5, // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØË®àÁÆó
      avgResponseTime: 250,
      activeUsers: 42,
      memoryUsage: 65.2,
      cpuUsage: 30.1,
    };
    
    // Â±•Ê≠¥„Éá„Éº„ÇøÔºàÂÆüË£Ö‰æãÔºâ
    const historicalData = {
      responseTimeHistory: [200, 220, 240, 230, 250, 260, 250],
      timeline: ['10:00', '10:30', '11:00', '11:30', '12:00', '12:30', '13:00'],
      errorTypeDistribution: {
        'ValidationError': 3,
        'NetworkError': 2,
        'DatabaseError': 1,
      },
      topPages: [
        { path: '/', views: 1500 },
        { path: '/posts/123', views: 800 },
        { path: '/auth/login', views: 600 },
      ],
    };
    
    return NextResponse.json({
      ...systemMetrics,
      ...historicalData,
      performanceStats,
      timestamp: new Date().toISOString(),
    });
    
  } catch (error) {
    console.error('„É°„Éà„É™„ÇØ„ÇπÂèñÂæó„Ç®„É©„Éº:', error);
    return NextResponse.json(
      { error: '„É°„Éà„É™„ÇØ„ÇπÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü' },
      { status: 500 }
    );
  }
}
```

### Step 10: Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Êõ¥Êñ∞

**next.config.js**ÔºàSentry„Ç¶„Ç£„Ç∂„Éº„ÉâÂÆüË°åÂæå„Å´ÁîüÊàê„Åï„Çå„ÇãË®≠ÂÆö„Å´ËøΩÂä†Ôºâ
```javascript
const { withSentryConfig } = require('@sentry/nextjs');

const nextConfig = {
  // Êó¢Â≠òË®≠ÂÆö
  experimental: {
    serverComponentsExternalPackages: ['@sentry/nextjs'],
  },
};

module.exports = withSentryConfig(
  nextConfig,
  {
    silent: true,
    org: process.env.SENTRY_ORG,
    project: process.env.SENTRY_PROJECT,
  },
  {
    widenClientFileUpload: true,
    transpileClientSDK: true,
    tunnelRoute: '/monitoring',
    hideSourceMaps: true,
    disableLogger: true,
  }
);
```

**package.json scriptsËøΩÂä†**
```json
{
  "scripts": {
    "monitor:check": "node -e \"console.log('Monitoring services check...')\"",
    "monitor:dashboard": "next dev -p 3010",
    "sentry:sourcemaps": "sentry-cli sourcemaps inject --org $SENTRY_ORG --project $SENTRY_PROJECT ./build && sentry-cli sourcemaps upload --org $SENTRY_ORG --project $SENTRY_PROJECT ./build"
  }
}
```

## ‚úÖ ÂÆå‰∫ÜÁ¢∫Ë™ç

### „ÉÜ„Çπ„ÉàÂÆüË°å
```bash
# Sentry„Ç®„É©„Éº„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞„ÉÜ„Çπ„Éà
npm run dev
# „Éñ„É©„Ç¶„Ç∂„ÅßÊÑèÂõ≥ÁöÑ„Å´„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„Å¶Sentry„Å´ÈÄÅ‰ø°„Åï„Çå„Çã„ÅãÁ¢∫Ë™ç

# „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ„ÉÜ„Çπ„Éà
# APIÂëº„Å≥Âá∫„Åó„ÇíÂÆüË°å„Åó„Å¶„É°„Éà„É™„ÇØ„Çπ„ÅåË®òÈå≤„Åï„Çå„Çã„ÅãÁ¢∫Ë™ç

# „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Ç¢„ÇØ„Çª„Çπ„ÉÜ„Çπ„Éà
# http://localhost:3010/monitoring/dashboard „Åß„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâË°®Á§∫Á¢∫Ë™ç

# „Ç¢„É©„Éº„Éà„ÉÜ„Çπ„Éà
# ÈñæÂÄ§„ÇíÊÑèÂõ≥ÁöÑ„Å´Ë∂Ö„Åà„Å¶„Ç¢„É©„Éº„Éà„ÅåÁô∫Âãï„Åô„Çã„ÅãÁ¢∫Ë™ç
```

### Áí∞Â¢ÉÂ§âÊï∞Ë®≠ÂÆö
```bash
# .env.local „Å´ËøΩÂä†
NEXT_PUBLIC_SENTRY_DSN=your_sentry_dsn_here
SENTRY_DSN=your_sentry_dsn_here
SENTRY_ORG=your_org
SENTRY_PROJECT=your_project
SLACK_WEBHOOK_URL=your_slack_webhook_url
```

## üéØ Phase 0.5ÂÆå‰∫ÜÊù°‰ª∂

- [ ] **Sentry„Ç®„É©„Éº„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞**: „Ç®„É©„ÉºËá™ÂãïÂèéÈõÜ„ÉªÈÄöÁü•Âãï‰Ωú
- [ ] **„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ**: „É°„Éà„É™„ÇØ„ÇπÂèéÈõÜ„ÉªÈñæÂÄ§„Ç¢„É©„Éº„ÉàÂãï‰Ωú  
- [ ] **Web VitalsÁõ£Ë¶ñ**: CLS/FID/LCP/FCP/TTFBÊ∏¨ÂÆöÂãï‰Ωú
- [ ] **„É¶„Éº„Ç∂„ÉºË°åÂãïËøΩË∑°**: „Ç§„Éô„É≥„ÉàÂèéÈõÜ„Éª„Çª„ÉÉ„Ç∑„Éß„É≥ÂàÜÊûêÂãï‰Ωú
- [ ] **„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ**: „É™„Ç¢„É´„Çø„Ç§„É†Ë°®Á§∫„Éª„ÉÅ„É£„Éº„ÉàÊèèÁîªÂãï‰Ωú
- [ ] **„Ç¢„É©„Éº„Éà„Ç∑„Çπ„ÉÜ„É†**: ÈñæÂÄ§Ë∂ÖÈÅéÊôÇ„ÅÆÈÄöÁü•Âãï‰Ωú

## üîÑ Ê¨°„ÅÆPhase„Å∏

```bash
# Â§âÊõ¥„Çí„Ç≥„Éü„ÉÉ„Éà
git add .
git commit -m "feat: Phase 0.5 - Ë¶≥Ê∏¨Âü∫Áõ§ÊßãÁØâÂÆå‰∫Ü

- SentryÁµ±Âêà„Éª„Ç®„É©„Éº„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞ÂÆüË£Ö
- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ„Éª„É°„Éà„É™„ÇØ„ÇπÂèéÈõÜÂÆüË£Ö  
- Web VitalsÁõ£Ë¶ñÂÆüË£Ö
- „É¶„Éº„Ç∂„ÉºË°åÂãïÂàÜÊûêÂü∫Áõ§ÂÆüË£Ö
- „É™„Ç¢„É´„Çø„Ç§„É†„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê
- „Ç¢„É©„Éº„Éà„Ç∑„Çπ„ÉÜ„É†ÊßãÁØâÂÆå‰∫Ü

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"

# develop„Å´„Éû„Éº„Ç∏
git checkout develop  
git merge feature/monitoring

# ÂÆå‰∫Ü„Çø„Ç∞
git tag phase-0.5-complete

# Phase 1Ê∫ñÂÇô
git checkout feature/monitoring
git checkout -b feature/auth-system
```

**Phase 0.5ÂÆå‰∫Ü„Å´„Çà„Çä„ÄÅ‰ª•Èôç„ÅÆÂÖ®Phase„Åß„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„ÉªÂìÅË≥™ÂèØË¶ñÂåñ„ÅåÂÆüÁèæ„Åï„Çå„Åæ„ÅôÔºÅ**